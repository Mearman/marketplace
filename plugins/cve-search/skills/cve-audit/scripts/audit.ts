#!/usr/bin/env npx tsx
/**
 * Scan project dependencies for CVE vulnerabilities
 * Usage: npx tsx audit.ts [directory] [options]
 *
 * Options:
 *   --severity <level>  Filter by severity: critical, high, medium, low (default: all)
 *   --no-cache          Bypass cache and fetch fresh data
 *   --json              Output as JSON
 */

import { resolve } from "path";
import {
	parseDependencies,
	scanForDependencyFiles,
	formatDependency,
	doesVersionMatch,
	type AuditResult,
	type VulnerabilityMatch,
} from "./audit-utils";
import {
	parseArgs,
	searchCVEByProduct,
} from "../../../skills/cve-lookup/scripts/utils";

const SEVERITY_LEVELS = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1, UNKNOWN: 0 };

const main = async () => {
	const { flags, options, positional } = parseArgs(process.argv.slice(2));
	const directory = positional[0] ? resolve(positional[0]) : process.cwd();
	const severity = options.get("severity")?.toUpperCase() || "";
	const bypassCache = flags.has("no-cache");
	const jsonOutput = flags.has("json");

	if (flags.has("help")) {
		console.log(`CVE Audit Tool - Scan project dependencies for vulnerabilities

Usage:
  npx tsx audit.ts [directory] [options]

Options:
  --severity <level>  Filter by severity: critical, high, medium, low (default: all)
  --no-cache          Bypass cache and fetch fresh data
  --json              Output as JSON
  --help              Show this help message

Examples:
  npx tsx audit.ts                           # Scan current directory
  npx tsx audit.ts /path/to/project
  npx tsx audit.ts --severity critical      # Only show critical vulns
  npx tsx audit.ts --severity high --no-cache`);
		process.exit(0);
	}

	try {
		console.log(`ðŸ” Scanning for dependencies in ${directory}...\n`);

		// Find and parse dependencies
		const depFiles = scanForDependencyFiles(directory);
		if (depFiles.length === 0) {
			console.log("âŒ No supported dependency files found");
			console.log("Supported files: package.json, requirements.txt, Gemfile, go.mod, pom.xml");
			process.exit(1);
		}

		console.log(`Found dependency files: ${depFiles.join(", ")}\n`);

		const dependencies = parseDependencies(directory);
		if (dependencies.length === 0) {
			console.log("âœ“ No dependencies found to audit");
			process.exit(0);
		}

		console.log(`Scanning ${dependencies.length} dependencies for CVEs...\n`);

		// Check each dependency for CVEs
		const vulnerabilities: VulnerabilityMatch[] = [];

		for (const dep of dependencies) {
			try {
				const cves = await searchCVEByProduct(dep.name, bypassCache, 50);

				for (const cve of cves) {
					// Check if the installed version is affected
					const affectsVersion = doesVersionMatch(dep.version, cve.id);

					if (affectsVersion) {
						vulnerabilities.push({
							cveId: cve.id,
							dependency: dep,
							severity: cve.severity || "UNKNOWN",
							score: cve.score,
							summary: cve.summary,
							affectsVersion: true,
						});
					}
				}
			} catch {
				// Silently skip dependencies that can't be searched
			}
		}

		// Calculate summary
		const summary = {
			total: vulnerabilities.length,
			critical: vulnerabilities.filter((v) => v.severity === "CRITICAL").length,
			high: vulnerabilities.filter((v) => v.severity === "HIGH").length,
			medium: vulnerabilities.filter((v) => v.severity === "MEDIUM").length,
			low: vulnerabilities.filter((v) => v.severity === "LOW").length,
		};

		// Filter by severity if specified
		let filtered = vulnerabilities;
		if (severity && severity in SEVERITY_LEVELS) {
			const minLevel = SEVERITY_LEVELS[severity as keyof typeof SEVERITY_LEVELS];
			filtered = vulnerabilities.filter((v) => {
				const vLevel = SEVERITY_LEVELS[v.severity as keyof typeof SEVERITY_LEVELS] || 0;
				return vLevel >= minLevel;
			});
		}

		// Sort by severity descending, then by score descending
		filtered.sort((a, b) => {
			const severityDiff =
        (SEVERITY_LEVELS[b.severity as keyof typeof SEVERITY_LEVELS] || 0) -
        (SEVERITY_LEVELS[a.severity as keyof typeof SEVERITY_LEVELS] || 0);
			if (severityDiff !== 0) return severityDiff;
			return (b.score || 0) - (a.score || 0);
		});

		// Output results
		if (jsonOutput) {
			const result: AuditResult = {
				dependencies,
				vulnerabilities: filtered,
				summary,
			};
			console.log(JSON.stringify(result, null, 2));
		} else {
			console.log("ðŸ“Š Audit Results\n");
			console.log(`Total vulnerabilities found: ${summary.total}`);
			console.log(
				`  ðŸ”´ Critical: ${summary.critical} | ðŸŸ  High: ${summary.high} | ðŸŸ¡ Medium: ${summary.medium} | ðŸ”µ Low: ${summary.low}`
			);

			if (filtered.length === 0) {
				console.log("\nâœ“ No vulnerabilities found (or filtered by severity)");
			} else {
				console.log(`\nShowing ${filtered.length} vulnerabilities:\n`);

				// Group by dependency
				const byDep = new Map<string, VulnerabilityMatch[]>();
				for (const vuln of filtered) {
					const key = `${vuln.dependency.name}@${vuln.dependency.version}`;
					if (!byDep.has(key)) {
						byDep.set(key, []);
					}
          byDep.get(key)!.push(vuln);
				}

				for (const [, vulns] of byDep.entries()) {
					const dep = vulns[0].dependency;
					console.log(`${formatDependency(dep)} - ${vulns.length} vulnerability(ies)\n`);

					vulns.forEach((vuln, idx) => {
						const severityEmoji: Record<string, string> = {
							CRITICAL: "ðŸ”´",
							HIGH: "ðŸŸ ",
							MEDIUM: "ðŸŸ¡",
							LOW: "ðŸ”µ",
							UNKNOWN: "âšª",
						};
						console.log(`  ${severityEmoji[vuln.severity] || "âšª"} ${vuln.cveId}`);
						console.log(`     Score: ${vuln.score || "N/A"} | ${vuln.summary}`);
						if (idx < vulns.length - 1) console.log();
					});

					console.log("\n" + "â”€".repeat(60) + "\n");
				}
			}

			// Recommendations
			if (summary.critical > 0 || summary.high > 0) {
				console.log("âš ï¸  Recommendations:");
				console.log("  1. Update dependencies to patched versions");
				console.log("  2. Review CVE details at https://cve.mitre.org/");
				console.log("  3. Use --no-cache for latest vulnerability data");
			}
		}

		process.exit(filtered.length > 0 && !severity ? 1 : 0);
	} catch (error) {
		console.error("Error:", error instanceof Error ? error.message : error);
		process.exit(1);
	}
};

main();
