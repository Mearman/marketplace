/**
 * Dependency parsing utilities for CVE audit
 */

import { readFileSync } from "fs";
import { existsSync } from "fs";
import { join } from "path";
import { isRecord, isString } from "../../../../../lib/type-guards";

// ============================================================================
// Types
// ============================================================================

export interface Dependency {
  name: string;
  version: string;
  source: "npm" | "pip" | "ruby" | "go" | "maven";
  file: string;
}

export interface AuditResult {
  dependencies: Dependency[];
  vulnerabilities: VulnerabilityMatch[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

export interface VulnerabilityMatch {
  cveId: string;
  dependency: Dependency;
  severity: string;
  score?: number;
  summary: string;
  affectsVersion: boolean;
}

// ============================================================================
// Dependency Detection & Parsing
// ============================================================================

/**
 * Scan directory for supported dependency files
 */
export const scanForDependencyFiles = (directory: string): string[] => {
	const files = [
		"package.json",
		"package-lock.json",
		"yarn.lock",
		"requirements.txt",
		"Gemfile",
		"go.mod",
		"pom.xml",
	];

	return files.filter((file) => existsSync(join(directory, file)));
};

/**
 * Parse all dependency files in a directory
 */
export const parseDependencies = (directory: string): Dependency[] => {
	const dependencies: Dependency[] = [];
	const files = scanForDependencyFiles(directory);

	for (const file of files) {
		const path = join(directory, file);
		try {
			if (file === "package.json") {
				dependencies.push(...parsePackageJson(path));
			} else if (file === "requirements.txt") {
				dependencies.push(...parseRequirementsTxt(path));
			} else if (file === "Gemfile") {
				dependencies.push(...parseGemfile(path));
			} else if (file === "go.mod") {
				dependencies.push(...parseGoMod(path));
			} else if (file === "pom.xml") {
				dependencies.push(...parsePomXml(path));
			}
		} catch (error) {
			console.warn(`Failed to parse ${file}:`, error instanceof Error ? error.message : error);
		}
	}

	// Remove duplicates
	const seen = new Set<string>();
	return dependencies.filter((dep) => {
		const key = `${dep.name}@${dep.version}`;
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
};

/**
 * Type guard for string-keyed dependency object
 */
const isStringRecord = (value: unknown): value is Record<string, string> => {
	if (!isRecord(value)) return false;
	for (const key of Object.keys(value)) {
		if (!isString(value[key])) return false;
	}
	return true;
};

/**
 * Parse package.json (Node.js/npm)
 */
const parsePackageJson = (path: string): Dependency[] => {
	const deps: Dependency[] = [];
	try {
		const content = readFileSync(path, "utf-8");
		const parsed: unknown = JSON.parse(content);

		if (!isRecord(parsed)) {
			throw new Error("Invalid package.json format");
		}

		const processDeps = (depObj: Record<string, string>, source: Dependency["source"]) => {
			for (const [name, version] of Object.entries(depObj)) {
				// Clean version string (remove ^, ~, >, <, =, *, etc)
				const cleanVersion = cleanVersionString(version);
				if (cleanVersion) {
					deps.push({ name, version: cleanVersion, source, file: path });
				}
			}
		};

		if (isStringRecord(parsed.dependencies)) {
			processDeps(parsed.dependencies, "npm");
		}
		if (isStringRecord(parsed.devDependencies)) {
			processDeps(parsed.devDependencies, "npm");
		}
		if (isStringRecord(parsed.peerDependencies)) {
			processDeps(parsed.peerDependencies, "npm");
		}
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		throw new Error(`Failed to parse package.json: ${message}`);
	}
	return deps;
};

/**
 * Parse requirements.txt (Python/pip)
 */
const parseRequirementsTxt = (path: string): Dependency[] => {
	const deps: Dependency[] = [];
	try {
		const content = readFileSync(path, "utf-8");
		const lines = content.split("\n");

		for (const line of lines) {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith("#")) continue;

			// Handle various formats: package==1.0, package>=1.0, package[extra]==1.0
			const match = trimmed.match(/^([a-zA-Z0-9._-]+)(?:\[[^\]]*\])?[\s]*[=><~!]+[\s]*([a-zA-Z0-9._*+-]+)/);
			if (match) {
				const [, name, version] = match;
				deps.push({ name: name.toLowerCase(), version: cleanVersionString(version), source: "pip", file: path });
			}
		}
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		throw new Error(`Failed to parse requirements.txt: ${message}`);
	}
	return deps;
};

/**
 * Parse Gemfile (Ruby/Bundler)
 */
const parseGemfile = (path: string): Dependency[] => {
	const deps: Dependency[] = [];
	try {
		const content = readFileSync(path, "utf-8");
		const lines = content.split("\n");

		for (const line of lines) {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith("#")) continue;

			// Handle: gem 'name', '1.0' or gem "name", "~> 1.0"
			const match = trimmed.match(/^\s*gem\s+['"]([a-zA-Z0-9._-]+)['"](?:\s*,\s*['"]([^'"]+)['"])?/);
			if (match) {
				const [, name, version] = match;
				// Only add if version is explicitly specified (not use "latest" as default)
				if (version) {
					const cleanVersion = cleanVersionString(version);
					deps.push({ name, version: cleanVersion, source: "ruby", file: path });
				}
			}
		}
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		throw new Error(`Failed to parse Gemfile: ${message}`);
	}
	return deps;
};

/**
 * Parse go.mod (Go modules)
 */
const parseGoMod = (path: string): Dependency[] => {
	const deps: Dependency[] = [];
	try {
		const content = readFileSync(path, "utf-8");
		const lines = content.split("\n");
		let inRequireBlock = false;

		for (const line of lines) {
			const trimmed = line.trim();

			if (trimmed === "require (") {
				inRequireBlock = true;
				continue;
			}

			if (trimmed === ")") {
				inRequireBlock = false;
				continue;
			}

			if (inRequireBlock || trimmed.startsWith("require ")) {
				// Format: github.com/user/repo v1.2.3 or v1.2.3-20230101120000-abcdef123456 (pseudo-version)
				const match = trimmed.replace(/^require\s+/, "").match(/^([a-zA-Z0-9._\/-]+)\s+(v[\da-z.+-]+)/);
				if (match) {
					const [, moduleName, version] = match;
					deps.push({
						name: moduleName,
						version: cleanVersionString(version),
						source: "go",
						file: path,
					});
				}
			}
		}
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		throw new Error(`Failed to parse go.mod: ${message}`);
	}
	return deps;
};

/**
 * Parse pom.xml (Maven)
 */
const parsePomXml = (path: string): Dependency[] => {
	const deps: Dependency[] = [];
	try {
		const content = readFileSync(path, "utf-8");

		// Extract groupId:artifactId:version from dependency tags
		const depRegex = /<dependency>[\s\S]*?<\/dependency>/g;
		const matches = content.match(depRegex) || [];

		for (const depBlock of matches) {
			const artifactIdMatch = depBlock.match(/<artifactId>([^<]+)<\/artifactId>/);
			const versionMatch = depBlock.match(/<version>([^<]+)<\/version>/);

			if (artifactIdMatch) {
				const artifactId = artifactIdMatch[1];
				const version = versionMatch ? cleanVersionString(versionMatch[1]) : "latest";
				deps.push({
					name: artifactId,
					version,
					source: "maven",
					file: path,
				});
			}
		}
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		throw new Error(`Failed to parse pom.xml: ${message}`);
	}
	return deps;
};

// ============================================================================
// Version Utilities
// ============================================================================

/**
 * Clean version string by removing operators and special characters
 */
const cleanVersionString = (version: string): string => {
	if (!version || version === "*") return "latest";

	// Remove leading operators: ^, ~, >=, >, <=, <, =, etc.
	let cleaned = version.replace(/^[\^~><=!]+\s*/, "");

	// Remove trailing qualifiers like -alpha, -beta, -rc
	cleaned = cleaned.split(/[-+]/)[0];

	// Handle version ranges - just take the first version
	cleaned = cleaned.split(/[\s,]/)[0];

	return cleaned || "latest";
};

/**
 * Check if a version matches or is affected by a version range
 */
export const doesVersionMatch = (installedVersion: string, affectedRange: string): boolean => {
	if (!affectedRange || affectedRange === "latest" || installedVersion === "latest") {
		return true;
	}

	// Simple version comparison: X.Y.Z format
	try {
		const installed = parseVersion(installedVersion);
		const affected = parseVersion(affectedRange);

		// If installed version is less than or equal to affected, it's vulnerable
		return compareVersions(installed, affected) <= 0;
	} catch {
		// If we can't parse, assume it matches (be conservative)
		return true;
	}
};

interface ParsedVersion {
  major: number;
  minor: number;
  patch: number;
}

const parseVersion = (version: string): ParsedVersion => {
	const parts = version.split(".").map((p) => parseInt(p, 10) || 0);
	return {
		major: parts[0] || 0,
		minor: parts[1] || 0,
		patch: parts[2] || 0,
	};
};

const compareVersions = (v1: ParsedVersion, v2: ParsedVersion): number => {
	if (v1.major !== v2.major) return v1.major - v2.major;
	if (v1.minor !== v2.minor) return v1.minor - v2.minor;
	return v1.patch - v2.patch;
};

/**
 * Format dependency for display
 */
export const formatDependency = (dep: Dependency): string => {
	const icons: Record<Dependency["source"], string> = {
		npm: "üì¶",
		pip: "üêç",
		ruby: "üíé",
		go: "üêπ",
		maven: "‚òï",
	};
	return `${icons[dep.source]} ${dep.name}@${dep.version}`;
};
