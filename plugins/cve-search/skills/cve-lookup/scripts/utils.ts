/**
 * Shared utilities for CVE lookup scripts
 */

import { createCacheManager } from "../../../../../lib/cache";
import { parseArgs as sharedParseArgs } from "../../../../../lib/args";
import { formatDate } from "../../../../../lib/helpers";

// ============================================================================
// Types
// ============================================================================

export interface CVEInfo {
  id: string;
  summary: string;
  score?: number;
  severity?: string;
  published: string;
  modified?: string;
  cvss_v2?: {
    score: number;
    vector: string;
  };
  cvss_v3?: {
    score: number;
    vector: string;
  };
  affected: Array<{
    vendor?: string;
    product?: string;
    versions?: string[];
  }>;
  references?: string[];
  cwe?: string[];
}

export interface SearchResult {
  cves: CVEInfo[];
  total: number;
}

// OpenCVE API Response Types
interface OpenCVEResponseItem {
  cveid?: string;
  id?: string;
  summary?: string;
  description?: string;
  cvss?: number;
  cvss_score?: number;
  severity?: string;
  created_at?: string;
  published_date?: string;
  updated_at?: string;
  modified_date?: string;
  cvss_v3?: { score?: number; vector?: string };
  cvss_v2?: { score?: number; vector?: string };
  vendors?: Array<{ name?: string; product?: string; versions?: string[] }>;
  products?: Array<{ name?: string; versions?: string[] } | string>;
  references?: string[];
  urls?: string[];
  cwe?: string[];
  weaknesses?: string[];
}

interface OpenCVEResponse {
  results: OpenCVEResponseItem[];
}

// ============================================================================
// Cache Manager
// ============================================================================

// Create cache manager for CVE namespace (24 hour TTL - vulnerabilities don't change frequently)
const cache = createCacheManager("cve-search", {
	defaultTTL: 86400,
});

export const { fetchWithCache, clearCache } = cache;

// ============================================================================
// Re-export shared utilities
// ============================================================================

export const parseArgs = sharedParseArgs;
export type { ParsedArgs } from "../../../../../lib/args";

// ============================================================================
// API Functions
// ============================================================================

/**
 * Search for CVEs by ID using OpenCVE API
 */
export const searchCVEById = async (
	cveId: string,
	bypassCache: boolean = false
): Promise<CVEInfo | null> => {
	// Normalize CVE ID format
	const normalizedId = cveId.toUpperCase();
	if (!normalizedId.match(/^CVE-\d{4}-\d{4,}$/)) {
		throw new Error(
			`Invalid CVE ID format: ${cveId}. ` +
			`Expected format: CVE-YYYY-NNNNN where YYYY is the year (1999-present) ` +
			`and NNNNN is the sequential number (e.g., CVE-2024-1234, CVE-2023-56789)`
		);
	}

	const url = `https://www.opencve.io/api/cve?cveid=${normalizedId}`;

	try {
		const data = await fetchWithCache<OpenCVEResponse>({
			url,
			ttl: 86400,
			bypassCache,
		});

		if (!data || !data.results || data.results.length === 0) {
			return null;
		}

		return parseOpenCVEResponse(data.results[0]);
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		if (message.includes("404")) {
			return null;
		}
		throw error;
	}
};

/**
 * Search for CVEs by product/vendor using OpenCVE API
 */
export const searchCVEByProduct = async (
	query: string,
	bypassCache: boolean = false,
	limit: number = 10
): Promise<CVEInfo[]> => {
	const url = `https://www.opencve.io/api/cves?limit=${limit}&search=${encodeURIComponent(query)}`;

	try {
		const data = await fetchWithCache<OpenCVEResponse>({
			url,
			ttl: 86400,
			bypassCache,
		});

		if (!data || !data.results) {
			return [];
		}

		return data.results.map((item: OpenCVEResponseItem) => parseOpenCVEResponse(item));
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		if (message.includes("404")) {
			return [];
		}
		throw error;
	}
};

/**
 * Parse OpenCVE API response into our CVEInfo format
 */
const parseOpenCVEResponse = (data: OpenCVEResponseItem): CVEInfo => {
	const score = data.cvss ?? data.cvss_score;
	const cveId = data.cveid || data.id;
	if (!cveId) {
		throw new Error("Invalid CVE response: missing CVE ID");
	}
	return {
		id: cveId,
		summary: data.summary || data.description || "",
		score: typeof score === "number" ? score : undefined,
		severity: data.severity || deriveSeverity(typeof score === "number" ? score : undefined),
		published: data.created_at || data.published_date || "",
		modified: data.updated_at || data.modified_date,
		cvss_v3: data.cvss_v3
			? {
				score: typeof data.cvss_v3.score === "number" ? data.cvss_v3.score : 0,
				vector: data.cvss_v3.vector || "",
			}
			: undefined,
		cvss_v2: data.cvss_v2
			? {
				score: typeof data.cvss_v2.score === "number" ? data.cvss_v2.score : 0,
				vector: data.cvss_v2.vector || "",
			}
			: undefined,
		affected: parseAffected(data),
		references: data.references || data.urls || [],
		cwe: data.cwe || data.weaknesses || [],
	};
};

/**
 * Parse affected products from OpenCVE response
 */
const parseAffected = (data: OpenCVEResponseItem) => {
	const affected: Array<{ vendor?: string; product?: string; versions?: string[] }> = [];

	if (data.vendors) {
		data.vendors.forEach((vendor) => {
			affected.push({
				vendor: vendor.name ?? undefined,
				product: vendor.product,
				versions: vendor.versions || [],
			});
		});
	}

	if (data.products) {
		const productList = Array.isArray(data.products) ? data.products : [data.products];
		productList.forEach((product) => {
			const versions = typeof product === "string" ? [] : (product.versions || []);
			affected.push({
				product: typeof product === "string" ? product : product.name,
				versions,
			});
		});
	}

	if (affected.length === 0 && data.description) {
		// Extract product info from description if available
		affected.push({});
	}

	return affected;
};

/**
 * Derive severity from CVSS score
 */
const deriveSeverity = (score?: number): string => {
	if (!score) return "UNKNOWN";
	if (score >= 9.0) return "CRITICAL";
	if (score >= 7.0) return "HIGH";
	if (score >= 4.0) return "MEDIUM";
	if (score > 0) return "LOW";
	return "UNKNOWN";
};

/**
 * Format CVE info for display
 */
export const formatCVEOutput = (cve: CVEInfo): string => {
	const lines: string[] = [];

	lines.push(`\nðŸ“‹ ${cve.id}`);
	lines.push(`Severity: ${cve.severity || "UNKNOWN"} ${cve.score ? `(CVSS ${cve.score})` : ""}`);
	lines.push(`Published: ${formatDate(new Date(cve.published))}`);

	if (cve.modified) {
		lines.push(`Modified: ${formatDate(new Date(cve.modified))}`);
	}

	if (cve.summary) {
		lines.push("\nSummary:");
		lines.push(formatParagraph(cve.summary, 2));
	}

	if (cve.cvss_v3 && cve.cvss_v3.score) {
		lines.push(`\nCVSS v3.1: ${cve.cvss_v3.score} (${cve.cvss_v3.vector})`);
	} else if (cve.cvss_v2 && cve.cvss_v2.score) {
		lines.push(`\nCVSS v2.0: ${cve.cvss_v2.score} (${cve.cvss_v2.vector})`);
	}

	if (cve.affected && cve.affected.length > 0) {
		lines.push("\nAffected Software:");
		cve.affected.forEach((item, i) => {
			const parts: string[] = [];
			if (item.vendor) parts.push(item.vendor);
			if (item.product) parts.push(item.product);
			if (parts.length > 0) {
				lines.push(`  ${i + 1}. ${parts.join(" - ")}`);
				if (item.versions && item.versions.length > 0) {
					const versionStr = item.versions.slice(0, 5).join(", ");
					const moreCount = item.versions.length - 5;
					lines.push(`     Versions: ${versionStr}${moreCount > 0 ? ` ... and ${moreCount} more` : ""}`);
				}
			}
		});
	}

	if (cve.cwe && cve.cwe.length > 0) {
		lines.push(`\nWeaknesses: ${cve.cwe.slice(0, 3).join(", ")}`);
	}

	if (cve.references && cve.references.length > 0) {
		lines.push("\nReferences:");
		cve.references.slice(0, 3).forEach((ref, i) => {
			lines.push(`  ${i + 1}. ${ref}`);
		});
		if (cve.references.length > 3) {
			lines.push(`  ... and ${cve.references.length - 3} more`);
		}
	}

	lines.push("");
	return lines.join("\n");
};

/**
 * Format paragraph with indentation
 */
const formatParagraph = (text: string, indent: number): string => {
	const spaces = " ".repeat(indent);
	return spaces + text.replace(/\n/g, "\n" + spaces);
};
