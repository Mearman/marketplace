/**
 * Shared utilities for CVE lookup scripts
 */

import { createCacheManager } from "../../../lib/cache";
import { parseArgs as sharedParseArgs } from "../../../lib/args";
import { formatDate } from "../../../lib/helpers";

// ============================================================================
// Types
// ============================================================================

export interface CVEInfo {
  id: string;
  summary: string;
  score?: number;
  severity?: string;
  published: string;
  modified?: string;
  cvss_v2?: {
    score: number;
    vector: string;
  };
  cvss_v3?: {
    score: number;
    vector: string;
  };
  affected: Array<{
    vendor?: string;
    product?: string;
    versions?: string[];
  }>;
  references?: string[];
  cwe?: string[];
}

export interface SearchResult {
  cves: CVEInfo[];
  total: number;
}

// ============================================================================
// Cache Manager
// ============================================================================

// Create cache manager for CVE namespace (24 hour TTL - vulnerabilities don't change frequently)
const cache = createCacheManager("cve-search", {
  defaultTTL: 86400,
});

export const { fetchWithCache, clearCache } = cache;

// ============================================================================
// Re-export shared utilities
// ============================================================================

export const parseArgs = sharedParseArgs;
export type { ParsedArgs } from "../../../lib/args";

// ============================================================================
// API Functions
// ============================================================================

/**
 * Search for CVEs by ID using OpenCVE API
 */
export const searchCVEById = async (
  cveId: string,
  bypassCache: boolean = false
): Promise<CVEInfo | null> => {
  // Normalize CVE ID format
  const normalizedId = cveId.toUpperCase();
  if (!normalizedId.match(/^CVE-\d{4}-\d{4,}$/)) {
    throw new Error(`Invalid CVE ID format: ${cveId}. Expected format: CVE-YYYY-NNNNN`);
  }

  const url = `https://www.opencve.io/api/cve?cveid=${normalizedId}`;

  try {
    const data = await fetchWithCache<any>({
      url,
      ttl: 86400,
      bypassCache,
    });

    if (!data || !data.results || data.results.length === 0) {
      return null;
    }

    return parseOpenCVEResponse(data.results[0]);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (message.includes("404")) {
      return null;
    }
    throw error;
  }
};

/**
 * Search for CVEs by product/vendor using OpenCVE API
 */
export const searchCVEByProduct = async (
  query: string,
  bypassCache: boolean = false,
  limit: number = 10
): Promise<CVEInfo[]> => {
  const url = `https://www.opencve.io/api/cves?limit=${limit}&search=${encodeURIComponent(query)}`;

  try {
    const data = await fetchWithCache<any>({
      url,
      ttl: 86400,
      bypassCache,
    });

    if (!data || !data.results) {
      return [];
    }

    return data.results.map((item: any) => parseOpenCVEResponse(item));
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (message.includes("404")) {
      return [];
    }
    throw error;
  }
};

/**
 * Parse OpenCVE API response into our CVEInfo format
 */
const parseOpenCVEResponse = (data: any): CVEInfo => {
  return {
    id: data.cveid || data.id,
    summary: data.summary || data.description || "",
    score: data.cvss || data.cvss_score,
    severity: data.severity || deriveSeverity(data.cvss || data.cvss_score),
    published: data.created_at || data.published_date || "",
    modified: data.updated_at || data.modified_date,
    cvss_v3: data.cvss_v3
      ? {
          score: data.cvss_v3.score || data.cvss_v3,
          vector: data.cvss_v3.vector || "",
        }
      : undefined,
    cvss_v2: data.cvss_v2
      ? {
          score: data.cvss_v2.score || data.cvss_v2,
          vector: data.cvss_v2.vector || "",
        }
      : undefined,
    affected: parseAffected(data),
    references: data.references || data.urls || [],
    cwe: data.cwe || data.weaknesses || [],
  };
};

/**
 * Parse affected products from OpenCVE response
 */
const parseAffected = (data: any) => {
  const affected: Array<{ vendor?: string; product?: string; versions?: string[] }> = [];

  if (data.vendors) {
    data.vendors.forEach((vendor: any) => {
      affected.push({
        vendor: vendor.name || vendor,
        product: vendor.product,
        versions: vendor.versions || [],
      });
    });
  }

  if (data.products) {
    const productList = Array.isArray(data.products) ? data.products : [data.products];
    productList.forEach((product: any) => {
      affected.push({
        product: typeof product === "string" ? product : product.name,
        versions: product.versions || [],
      });
    });
  }

  if (affected.length === 0 && data.description) {
    // Extract product info from description if available
    affected.push({});
  }

  return affected;
};

/**
 * Derive severity from CVSS score
 */
const deriveSeverity = (score?: number): string => {
  if (!score) return "UNKNOWN";
  if (score >= 9.0) return "CRITICAL";
  if (score >= 7.0) return "HIGH";
  if (score >= 4.0) return "MEDIUM";
  if (score > 0) return "LOW";
  return "UNKNOWN";
};

/**
 * Format CVE info for display
 */
export const formatCVEOutput = (cve: CVEInfo): string => {
  const lines: string[] = [];

  lines.push(`\nðŸ“‹ ${cve.id}`);
  lines.push(`Severity: ${cve.severity || "UNKNOWN"} ${cve.score ? `(CVSS ${cve.score})` : ""}`);
  lines.push(`Published: ${formatDate(new Date(cve.published))}`);

  if (cve.modified) {
    lines.push(`Modified: ${formatDate(new Date(cve.modified))}`);
  }

  if (cve.summary) {
    lines.push(`\nSummary:`);
    lines.push(formatParagraph(cve.summary, 2));
  }

  if (cve.cvss_v3 && cve.cvss_v3.score) {
    lines.push(`\nCVSS v3.1: ${cve.cvss_v3.score} (${cve.cvss_v3.vector})`);
  } else if (cve.cvss_v2 && cve.cvss_v2.score) {
    lines.push(`\nCVSS v2.0: ${cve.cvss_v2.score} (${cve.cvss_v2.vector})`);
  }

  if (cve.affected && cve.affected.length > 0) {
    lines.push(`\nAffected Software:`);
    cve.affected.forEach((item, i) => {
      const parts: string[] = [];
      if (item.vendor) parts.push(item.vendor);
      if (item.product) parts.push(item.product);
      if (parts.length > 0) {
        lines.push(`  ${i + 1}. ${parts.join(" - ")}`);
        if (item.versions && item.versions.length > 0) {
          const versionStr = item.versions.slice(0, 5).join(", ");
          const moreCount = item.versions.length - 5;
          lines.push(`     Versions: ${versionStr}${moreCount > 0 ? ` ... and ${moreCount} more` : ""}`);
        }
      }
    });
  }

  if (cve.cwe && cve.cwe.length > 0) {
    lines.push(`\nWeaknesses: ${cve.cwe.slice(0, 3).join(", ")}`);
  }

  if (cve.references && cve.references.length > 0) {
    lines.push(`\nReferences:`);
    cve.references.slice(0, 3).forEach((ref, i) => {
      lines.push(`  ${i + 1}. ${ref}`);
    });
    if (cve.references.length > 3) {
      lines.push(`  ... and ${cve.references.length - 3} more`);
    }
  }

  lines.push("");
  return lines.join("\n");
};

/**
 * Format paragraph with indentation
 */
const formatParagraph = (text: string, indent: number): string => {
  const spaces = " ".repeat(indent);
  return spaces + text.replace(/\n/g, "\n" + spaces);
};
